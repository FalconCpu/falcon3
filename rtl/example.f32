# Filename: mem_stress_test.s
# Purpose: Comprehensive test for byte, half-word, and word memory accesses.
#          Includes testing of signed/unsigned loads and writes, and offset variations.
# Assumes Little-Endian memory.

# R1 will hold our base memory address (0x1000)
ld  $1, 0x1000

# --- Initial Memory Setup ---
# Write known 32-bit words to memory to set up a baseline
# Mem[0x1000] will be 0xDEADBEEF (0xEF at 0x1000, 0xBE at 0x1001, 0xAD at 0x1002, 0xDE at 0x1003)
ld  $2, 0xDEADBEEF
stw $2, $1[0]

# Mem[0x1004] will be 0x12345678 (0x78 at 0x1004, 0x56 at 0x1005, 0x34 at 0x1006, 0x12 at 0x1007)
ld  $3, 0x12345678
stw $3, $1[4]

# Mem[0x1008] will be 0xFFEEDDCC (0xCC at 0x1008, 0xDD at 0x1009, 0xEE at 0x100A, 0xFF at 0x100B)
ld  $4, 0xFFEEDDCC
stw $4, $1[8]


# --- Test Byte Loads (LDBU = Unsigned, LDB = Signed) ---
# Expected: Values read should be zero-extended for LDBU, sign-extended for LDB.

ldb  $12, $1[2]      # R12 = Mem[0x1002] (byte 0xAD)  -> 0xFFFFFFAD (signed, 0xAD is 10101101, negative)
ldb  $13, $1[3]      # R13 = Mem[0x1003] (byte 0xDE)  -> 0xFFFFFFDE (signed, 0xDE is 11011110, negative)

ldb  $14, $1[4]      # R14 = Mem[0x1004] (byte 0x78)  -> 0x00000078 (unsigned)
ldb  $15, $1[5]      # R15 = Mem[0x1005] (byte 0x56)  -> 0x00000056 (signed, 0x56 is positive)


# --- Test Half-Word Loads (LDHU = Unsigned, LDH = Signed) ---
# Expected: Values read should be zero-extended for LDHU, sign-extended for LDH.

ldh  $17, $1[2]      # R17 = Mem[0x1002] (half-word 0xDEAD) -> 0xFFFFDEAD (signed, 0xDEAD is negative)
ldh  $19, $1[6]      # R19 = Mem[0x1006] (half-word 0x1234) -> 0x00001234 (signed, 0x1234 is positive)


# --- Test Byte Stores (STB) and verify with LDBU ---
# We'll modify 0x1000 and 0x1004 then verify the full word at the end.
# Initial Mem[0x1000] = 0xDEADBEEF (0xEF 0xBE 0xAD 0xDE)
# Initial Mem[0x1004] = 0x12345678 (0x78 0x56 0x34 0x12)

ld   $20, 0xAA       # R20 = 0xAA
stb  $20, $1[0]      # Store 0xAA at 0x1000. Mem[0x1000] now: 0xAA 0xBE 0xAD 0xDE
ldb  $21, $1[0]      # R21 = Read 0xAA -> 0x000000AA (Verify store)

ld   $20, 0xBB       # R20 = 0xBB
stb  $20, $1[1]      # Store 0xBB at 0x1001. Mem[0x1000] now: 0xAA 0xBB 0xAD 0xDE
ldb  $21, $1[1]      # R21 = Read 0xBB -> 0x000000BB (Verify store)

ld   $20, 0xCC       # R20 = 0xCC
stb  $20, $1[2]      # Store 0xCC at 0x1002. Mem[0x1000] now: 0xAA 0xBB 0xCC 0xDE
ldb  $21, $1[2]      # R21 = Read 0xCC -> 0x000000CC (Verify store)

ld   $20, 0xDD       # R20 = 0xDD
stb  $20, $1[3]      # Store 0xDD at 0x1003. Mem[0x1000] now: 0xAA 0xBB 0xCC 0xDD
ldb  $21, $1[3]      # R21 = Read 0xDD -> 0x000000DD (Verify store)


# --- Test Half-Word Stores (STH) and verify with LDHU ---
# This will overwrite parts of the words at 0x1000 and 0x1004
# Current Mem[0x1000] = 0xDDC CBAA (0xAA 0xBB 0xCC 0xDD)

ld   $20, 0x1122     # R20 = 0x1122
sth  $20, $1[0]      # Store 0x1122 at 0x1000. Mem[0x1000] now: 0x22 0x11 0xCC 0xDD
ldh  $21, $1[0]      # R21 = Read 0x1122 -> 0x00001122 (Verify store)

ld   $20, 0x3344     # R20 = 0x3344
sth  $20, $1[2]      # Store 0x3344 at 0x1002. Mem[0x1000] now: 0x22 0x11 0x44 0x33
ldh  $21, $1[2]      # R21 = Read 0x3344 -> 0x00003344 (Verify store)

# Now test on the second word at 0x1004
# Current Mem[0x1004] = 0x12345678 (0x78 0x56 0x34 0x12)
ld   $20, 0xAABB     # R20 = 0xAABB
sth  $20, $1[4]      # Store 0xAABB at 0x1004. Mem[0x1004] now: 0xBB 0xAA 0x34 0x12
ldh  $21, $1[4]      # R21 = Read 0xAABB -> 0x0000AABB (Verify store)


# --- Final Word Load Verification ---
# Read back the full words to see the combined effect of byte/half-word writes.
ldw $22, $1[0]       # R22 = Mem[0x1000] (Expected: 0x33441122 after all byte/halfword modifications)
ldw $23, $1[4]       # R23 = Mem[0x1004] (Expected: 0x1234AABB after halfword modification)
ldw $24, $1[8]       # R24 = Mem[0x1008] (Expected: 0xFFEEDDCC, should be unchanged by this test)
