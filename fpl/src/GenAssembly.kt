/**
 * Generate the header for the assembly file
 */

fun genAssemblyHeader(sb: StringBuilder) {
    sb.append("# Generated by Falcon Compiler\n")

    if (allGlobalVars.isNotEmpty()) {
        sb.append("# Global vars:-\n")
        for (global in allGlobalVars)
            sb.append("# $global @ ${global.offset}\n")
    }
}


private fun InstrAlu.genAssembly() : String = when(op) {
    AluOp.ADD_I -> "add $dest, $lhs, $rhs"
    AluOp.SUB_I -> "sub $dest, $lhs, $rhs"
    AluOp.MUL_I -> "mul $dest, $lhs, $rhs"
    AluOp.DIV_I -> "divs $dest, $lhs, $rhs"
    AluOp.MOD_I -> "mods $dest, $lhs, $rhs"
    AluOp.AND_I -> "and $dest, $lhs, $rhs"
    AluOp.OR_I -> "or $dest, $lhs, $rhs"
    AluOp.XOR_I -> "xor $dest, $lhs, $rhs"
    AluOp.EQ_I -> "xor $dest, $lhs, $rhs\ncltu $dest, $dest, 1"
    AluOp.NEQ_I -> "xor $dest, $lhs, $rhs\ncltu $dest, 0, $dest"
    AluOp.LT_I -> "clt $dest, $lhs, $rhs"
    AluOp.GT_I -> "clt $dest, $rhs, $lhs"
    AluOp.LTE_I -> "clt $dest, $rhs, $lhs\nxor $dest, $dest, 1"
    AluOp.GTE_I -> "clt $dest, $lhs, $rhs\nxor $dest, $dest, 1"
    AluOp.SHL_I -> "lsl $dest, $lhs, $rhs"
    AluOp.SHR_I -> "lsr $dest, $lhs, $rhs"
    AluOp.ADD_R -> TODO()
    AluOp.SUB_R -> TODO()
    AluOp.MUL_R -> TODO()
    AluOp.DIV_R -> TODO()
    AluOp.MOD_R -> TODO()
    AluOp.EQ_R -> TODO()
    AluOp.NEQ_R -> TODO()
    AluOp.LT_R -> TODO()
    AluOp.GT_R -> TODO()
    AluOp.LTE_R -> TODO()
    AluOp.GTE_R -> TODO()
    AluOp.EQ_S,
    AluOp.NEQ_S,
    AluOp.LT_S,
    AluOp.GT_S,
    AluOp.LTE_S,
    AluOp.GTE_S-> error("Should have been lowered before genAssembly")
}

private fun InstrAluImm.genAssembly() : String = when(op) {
    AluOp.ADD_I -> "add $dest, $lhs, $rhs"
    AluOp.SUB_I -> "sub $dest, $lhs, $rhs"
    AluOp.MUL_I -> "mul $dest, $lhs, $rhs"
    AluOp.DIV_I -> "divs $dest, $lhs, $rhs"
    AluOp.MOD_I -> "mods $dest, $lhs, $rhs"
    AluOp.AND_I -> "and $dest, $lhs, $rhs"
    AluOp.OR_I -> "or $dest, $lhs, $rhs"
    AluOp.XOR_I -> "xor $dest, $lhs, $rhs"
    AluOp.EQ_I -> "xor $dest, $lhs, $rhs\ncltu $dest, $dest, 1"
    AluOp.NEQ_I -> "xor $dest, $lhs, $rhs\ncltu $dest, 0, $dest"
    AluOp.LT_I -> "clt $dest, $lhs, $rhs"
    AluOp.GT_I -> "clt $dest, $lhs, ${rhs+1}\nxor $dest, $dest, 1"
    AluOp.LTE_I -> "clt $dest, $lhs, ${rhs+1}\n"
    AluOp.GTE_I -> "clt $dest, $lhs, $rhs\nxor $dest, $dest, 1"
    AluOp.SHL_I -> "lsl $dest, $lhs, $rhs"
    AluOp.SHR_I -> "lsr $dest, $lhs, $rhs"
    AluOp.ADD_R -> TODO()
    AluOp.SUB_R -> TODO()
    AluOp.MUL_R -> TODO()
    AluOp.DIV_R -> TODO()
    AluOp.MOD_R -> TODO()
    AluOp.EQ_R -> TODO()
    AluOp.NEQ_R -> TODO()
    AluOp.LT_R -> TODO()
    AluOp.GT_R -> TODO()
    AluOp.LTE_R -> TODO()
    AluOp.GTE_R -> TODO()
    AluOp.EQ_S,
    AluOp.NEQ_S,
    AluOp.LT_S,
    AluOp.GT_S,
    AluOp.LTE_S,
    AluOp.GTE_S-> error("Should have been lowered before genAssembly")
}

private fun InstrBranch.genAssembly() : String = when (op) {
    AluOp.EQ_I -> "beq $lhs, $rhs, .$label"
    AluOp.NEQ_I -> "bne $lhs, $rhs, .$label"
    AluOp.LT_I -> "blt $lhs, $rhs, .$label"
    AluOp.GT_I -> "blt $rhs, $lhs, .$label"
    AluOp.LTE_I -> "bge $rhs, $lhs, .$label"
    AluOp.GTE_I -> "bge $lhs, $rhs, .$label"
    else -> error("Not a valid branch operand")
}

private fun Instr.genAssembly() = when(this) {
    is InstrAlu -> genAssembly()
    is InstrAluImm -> genAssembly()
    is InstrBranch -> genAssembly()
    is InstrCall -> "jsr /${func.name}"
    is InstrRet -> ""
    is InstrJump -> "jmp .$label"
    is InstrLabel -> ".$label:"
    is InstrMov -> "ld $dest, $src"
    is InstrNop -> "nop"
    is InstrStart -> ""
    is InstrCallIndirect -> TODO()
    is InstrLoadMem -> "${size.loadOp()} $dest, $addr[$offset]"
    is InstrMovImm -> "ld $dest, $src"
    is InstrStoreMem -> "${size.storeOp()} $src, $addr[$offset]"
    is InstrLea -> "ld $dest, $value"
    is InstrIndex -> "${scale.idxOp()} $dest, $src, $limit"
    is InstrLoadField -> "${size.loadOp()} $dest, $addr[${offset.offset}]"
    is InstrStoreField -> "${size.storeOp()} $src, $addr[${offset.offset}]"
    is InstrLoadGlobal -> "ldw $dest, R29[${global.offset}]"
    is InstrStoreGlobal -> "stw $src, R29[${global.offset}]"
    is InstrSyscall -> "sys $syscall"
}

fun Function.genAssembly(sb:StringBuilder) {
    if (name=="<TopLevel>")
        sb.append("init:\n")
    else
        sb.append("/$name:\n")

    for(comment in regAssignComments)
        sb.append("# $comment\n")

    // setup stack frame
    val makesCalls = code.any{it is InstrCall || it is InstrCallIndirect}
    val stackSize = stackVarSize + (if (maxRegister>8) 4*(maxRegister-8) else 0) + (if (makesCalls) 4 else 0)
    if (stackSize!=0) {
        sb.append("sub SP, SP, $stackSize\n")
        for(r in 9..maxRegister)
            sb.append("stw R$r, SP[${stackVarSize + 4*(r-9)}]\n")
        if (makesCalls)
            sb.append("stw R30, SP[${stackSize-4}]\n")
    }

    for(instr in code) {
        if (instr is InstrStart || instr is InstrRet)
            continue
        sb.append(instr.genAssembly())
        sb.append("\n")
    }

    // teardown stack frame
    if (stackSize!=0) {
        for(r in 9..maxRegister)
            sb.append("ldw R$r, SP[${stackVarSize + 4*(r-9)}]\n")
        if (makesCalls)
            sb.append("ldw R30, SP[${stackSize-4}]\n")
        sb.append("add SP, SP, $stackSize\n")
    }
    sb.append("ret\n\n")
}

fun TypeClass.generateClassDescriptor(sb: StringBuilder) {
    sb.append("$name/class:\n")
    sb.append("dcw $sizeInBytes\n")
    val nameAsValue = ValueString.create(name,TypeString)
    sb.append("dcw $nameAsValue\n")
    // When we get to it - vtable can go here
    sb.append("\n")
}

fun List<TypeClass>.generateClassDescriptors(sb: StringBuilder) {
    for(c in this)
        c.generateClassDescriptor(sb)
}